#!/usr/bin/env bash
set -euo pipefail

# ==============================================================================
# new-python-project-linux.sh
#
# Prerequisites:
#   - Ubuntu 24.04.x
#   - setup-aryan base already staged (so logs/state dirs exist)
#   - Python toolchain action already run (Miniconda + uv recommended)
#
# Usage:
#   setup-aryan new-python-project-linux --name <project_name> [--dir <base_dir>] [--ai]
#
# Examples:
#   setup-aryan new-python-project-linux --name demo-ml --ai
#   setup-aryan new-python-project-linux --name demo-py --dir /home/aryan/dev/projects
#
# Output:
#   Creates a complete starter kit:
#     - README.md + Quick Start
#     - project_config.yaml
#     - pyproject.toml
#     - requirements.txt
#     - src/main.py
#     - scripts/run.sh, scripts/dev.sh, scripts/test.sh, scripts/lint.sh
#     - .gitignore
#
# Logging:
#   - Logs to: /var/log/setup-aryan/new-python-project-linux.log
#   - State to: /var/log/setup-aryan/state-files/new-python-project-linux.state
# ==============================================================================

ACTION_NAME="new-python-project-linux"
LOG_DIR="/var/log/setup-aryan"
STATE_DIR="/var/log/setup-aryan/state-files"
LOG_FILE="${LOG_DIR}/${ACTION_NAME}.log"
STATE_FILE="${STATE_DIR}/${ACTION_NAME}.state"

ts() { TZ="Asia/Kolkata" date '+%Z %d-%m-%Y %H:%M:%S'; }
log() {
  local level="$1"; shift
  local msg="$*"
  mkdir -p "$LOG_DIR" "$STATE_DIR"
  printf '%s %s %s\n' "$(ts)" "$level" "$msg" | tee -a "$LOG_FILE" >/dev/null
}
die() { log "Error" "$*"; exit 1; }

ensure_root() {
  if [[ "${EUID}" -ne 0 ]]; then
    exec sudo -E bash "$0" "$@"
  fi
}

TARGET_USER="${SUDO_USER:-$USER}"
TARGET_HOME="$(getent passwd "$TARGET_USER" | cut -d: -f6)"

NAME=""
BASE_DIR="${TARGET_HOME}/dev/projects"
AI_MODE="false"

usage() {
  cat <<EOF
${ACTION_NAME}

Usage:
  ${ACTION_NAME} --name <project_name> [--dir <base_dir>] [--ai]
  ${ACTION_NAME} --help

Flags:
  --name <name>     Project name (folder name)
  --dir  <path>     Base directory (default: ${BASE_DIR})
  --ai              AI/ML mode (adds GPU/cache notes to README and config)
EOF
}

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --name) NAME="${2:-}"; shift 2 ;;
      --dir)  BASE_DIR="${2:-}"; shift 2 ;;
      --ai)   AI_MODE="true"; shift ;;
      -h|--help) usage; exit 0 ;;
      *) die "Unknown argument: $1 (use --help)" ;;
    esac
  done

  [[ -n "$NAME" ]] || die "--name is required"
  [[ "$NAME" =~ ^[a-zA-Z0-9._-]+$ ]] || die "Invalid --name '$NAME' (use only letters, digits, dot, underscore, hyphen)"
}

ensure_user_dirs() {
  install -d -m 0755 -o "$TARGET_USER" -g "$TARGET_USER" "$BASE_DIR"
}

write_if_missing() {
  local path="$1"
  local owner="$2"
  local group="$3"
  local mode="$4"
  local content="$5"

  if [[ -e "$path" ]]; then
    log "Debug" "Exists, not overwriting: $path"
    return 0
  fi

  install -d -m 0755 -o "$owner" -g "$group" "$(dirname "$path")"
  printf '%s' "$content" > "$path"
  chown "$owner:$group" "$path"
  chmod "$mode" "$path"
  log "Info" "Created: $path"
}

append_notice_if_missing() {
  local path="$1"
  local marker="$2"
  local block="$3"
  if [[ ! -f "$path" ]]; then
    return 0
  fi
  if grep -Fq "$marker" "$path"; then
    return 0
  fi
  printf '\n%s\n' "$block" >> "$path"
  log "Info" "Appended block to: $path"
}

main() {
  ensure_root "$@"
  parse_args "$@"

  log "Info" "Starting ${ACTION_NAME} (user=${TARGET_USER}, name=${NAME}, base_dir=${BASE_DIR}, ai=${AI_MODE})"

  ensure_user_dirs

  local project_dir="${BASE_DIR}/${NAME}"
  local template_version="1.0.0"
  local created_at
  created_at="$(ts)"

  if [[ -e "$project_dir" ]] && [[ -n "$(ls -A "$project_dir" 2>/dev/null || true)" ]]; then
    log "Warning" "Project directory exists and is not empty: $project_dir"
    log "Warning" "Idempotent behavior: will only create missing files (no overwrites)."
  fi

  install -d -m 0755 -o "$TARGET_USER" -g "$TARGET_USER" \
    "$project_dir" \
    "$project_dir/src" \
    "$project_dir/scripts"

  # .gitignore
  write_if_missing "$project_dir/.gitignore" "$TARGET_USER" "$TARGET_USER" "0644" \
".venv/
__pycache__/
*.pyc
.pytest_cache/
.coverage
dist/
build/
*.egg-info/
.env
.DS_Store
"

  # requirements.txt (empty starter)
  write_if_missing "$project_dir/requirements.txt" "$TARGET_USER" "$TARGET_USER" "0644" \
"# Add your Python deps here (pip-style), then run:
#   uv pip install -r requirements.txt
"

  # pyproject.toml (minimal)
  write_if_missing "$project_dir/pyproject.toml" "$TARGET_USER" "$TARGET_USER" "0644" \
"[project]
name = \"${NAME}\"
version = \"0.1.0\"
description = \"${NAME} (generated by setup-aryan)\"
readme = \"README.md\"
requires-python = \">=3.11\"

[tool.uv]
# uv will create and manage a local .venv by default if you use 'uv venv'
# Here we keep it simple and let conda own the interpreter, uv owns pip installs.
"

  # src/main.py (runnable)
  write_if_missing "$project_dir/src/main.py" "$TARGET_USER" "$TARGET_USER" "0644" \
"def main() -> None:
    print(\"Hello from ${NAME}!\")
    print(\"If this is an AI/ML project, activate your conda env and install deps via uv.\")

if __name__ == \"__main__\":
    main()
"

  # scripts helpers (idempotent, with help)
  write_if_missing "$project_dir/scripts/run.sh" "$TARGET_USER" "$TARGET_USER" "0755" \
"#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'EOF'
scripts/run.sh

Usage:
  ./scripts/run.sh
EOF
}

if [[ \"\${1:-}\" == \"-h\" || \"\${1:-}\" == \"--help\" ]]; then
  usage
  exit 0
fi

python3 ./src/main.py
"

  write_if_missing "$project_dir/scripts/dev.sh" "$TARGET_USER" "$TARGET_USER" "0755" \
"#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'EOF'
scripts/dev.sh

Usage:
  ./scripts/dev.sh

Notes:
  - For conda+uv workflow:
      conda activate <env>
      uv pip install -r requirements.txt
EOF
}

if [[ \"\${1:-}\" == \"-h\" || \"\${1:-}\" == \"--help\" ]]; then
  usage
  exit 0
fi

./scripts/run.sh
"

  write_if_missing "$project_dir/scripts/test.sh" "$TARGET_USER" "$TARGET_USER" "0755" \
"#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'EOF'
scripts/test.sh

Usage:
  ./scripts/test.sh

Default:
  - No tests scaffolded yet.
  - Add pytest to requirements.txt and create tests/ later.
EOF
}

if [[ \"\${1:-}\" == \"-h\" || \"\${1:-}\" == \"--help\" ]]; then
  usage
  exit 0
fi

echo \"No tests configured yet.\"
"

  write_if_missing "$project_dir/scripts/lint.sh" "$TARGET_USER" "$TARGET_USER" "0755" \
"#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'EOF'
scripts/lint.sh

Usage:
  ./scripts/lint.sh

Tip:
  - Add ruff/black to requirements.txt and run via uv:
      uv pip install ruff black
      ruff check .
      black --check .
EOF
}

if [[ \"\${1:-}\" == \"-h\" || \"\${1:-}\" == \"--help\" ]]; then
  usage
  exit 0
fi

echo \"No lint configured yet. See --help for suggestions.\"
"

  # project_config.yaml
  local toolchain="conda+uv"
  local caches_block=""
  caches_block="python:
  toolchain: \"${toolchain}\"
  caches:
    uv_cache_dir: \"${TARGET_HOME}/dev/cache/uv\"
    conda_pkgs_dir: \"${TARGET_HOME}/dev/cache/conda-pkgs\"
    conda_envs_dir: \"${TARGET_HOME}/dev/envs/conda\"
"

  local ai_block=""
  if [[ "$AI_MODE" == "true" ]]; then
    ai_block="ai_ml:
  enabled: true
  notes:
    - \"Linux PRIME On-Demand: apps default to iGPU; use NVIDIA offload vars only when needed.\"
    - \"Per-run NVIDIA offload (OpenGL): __NV_PRIME_RENDER_OFFLOAD=1 __GLX_VENDOR_LIBRARY_NAME=nvidia <cmd>\"
"
  else
    ai_block="ai_ml:
  enabled: false
"
  fi

  write_if_missing "$project_dir/project_config.yaml" "$TARGET_USER" "$TARGET_USER" "0644" \
"project:
  name: \"${NAME}\"
  type: \"python\"
  created_at: \"${created_at}\"
  template_version: \"${template_version}\"

${caches_block}
${ai_block}
"

  # README.md
  local readme_base
  readme_base="# ${NAME}

This project was generated by **setup-aryan** on Linux.

## Quick Start (Linux)

### 1) Create a conda environment (skeleton) and activate it
Choose an env name, for example: \`${NAME}-py\`

\`\`\`bash
# Create env (Python version example)
conda create -n ${NAME}-py python=3.11 -y
conda activate ${NAME}-py
\`\`\`

### 2) Install Python dependencies using uv (inside the active conda env)
\`\`\`bash
uv pip install -r requirements.txt
\`\`\`

### 3) Run
\`\`\`bash
./scripts/run.sh
\`\`\`

## What got generated

- \`project_config.yaml\`: records the chosen toolchain and expectations
- \`requirements.txt\`: add dependencies here
- \`src/main.py\`: minimal runnable entrypoint
- \`scripts/*.sh\`: helper runners (run/dev/test/lint)

## Notes on disk usage (conda + uv)

- Keep your project under \`${TARGET_HOME}/dev/projects\` and caches under \`${TARGET_HOME}/dev/cache\`.
- uv keeps a global cache and hard-links where possible, reducing duplication.
- Conda pkgs/envs are redirected via your \`~/.condarc\` (from the toolchain installer action).
"

  write_if_missing "$project_dir/README.md" "$TARGET_USER" "$TARGET_USER" "0644" "$readme_base"

  if [[ "$AI_MODE" == "true" ]]; then
    append_notice_if_missing "$project_dir/README.md" "## AI/ML Notes (Linux GPU)" \
"## AI/ML Notes (Linux GPU)

On Ubuntu with PRIME **On-Demand**, GNOME/Wayland and normal GUI apps typically run on the **iGPU by default**.

When you *explicitly* want NVIDIA offload for a specific run, use:

- OpenGL (common):
  \`\`\`bash
  __NV_PRIME_RENDER_OFFLOAD=1 __GLX_VENDOR_LIBRARY_NAME=nvidia <command>
  \`\`\`

- Vulkan (common):
  \`\`\`bash
  __NV_PRIME_RENDER_OFFLOAD=1 __VK_LAYER_NV_optimus=NVIDIA_only <command>
  \`\`\`

If you are keeping the dGPU mostly idle, prefer per-command offload instead of flipping system profiles.
"
  fi

  # State
  cat > "$STATE_FILE" <<EOF
installed=true
project_dir=${project_dir}
ai_mode=${AI_MODE}
timestamp="$(ts)"
EOF
  chmod 0644 "$STATE_FILE"
  log "Info" "Done: ${ACTION_NAME}"
  log "Info" "Created/validated project at: ${project_dir}"
  log "Info" "Next: cd \"${project_dir}\" && ./scripts/run.sh"
}

main "$@"
